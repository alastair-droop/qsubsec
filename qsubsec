#! /usr/bin/env python3

from collections import UserDict, UserList
from copy import deepcopy
from enum import Enum
from string import Formatter
from urllib.parse import urlparse
from urllib.request import urlopen
import argparse
import re
import subprocess
import sys

# Set the script version number:
version = '2.6 (2016-06-01)'

########################################################################################################################
# Tokens:

# Set the token error types:
class TokenError(Exception):
	"""Base class for exceptions relating to supplied tokens"""
	def __init__(self, tokens):
		self.tokens = tokens

class MissingTokenError(TokenError):
	"""Exception raised when missing necessary tokens"""
	pass

class CyclicTokenDependencyError(TokenError):
	"""Exception raised when supplied tokens form a cyclic graph"""
	pass

# Token formatter class:
class tokenFormatter(Formatter):
	"""This class overloads the base String Formatter class to provide token-specific formatting."""
	@classmethod
	def extractTokens(cls, s):
		if isinstance(s, str): s = [s]
		tokens = set()
		for i in s:
			for j in super().parse(s, i):
				if j[1] != None: tokens.add(j[1])
		return tokens
	def get_value(self, key, args, kwargs):
		return kwargs[key]
	def format(self, string, token_dict):
		return super().format(string, None, **token_dict)


# A single set of tokens, in which each token has a single value:
class tokenDict(UserDict):
	"""This class encapsulates a single set of tokens, each of which has a single value"""
	def __init__(self, data={}, formatter=None):
		if formatter == None: self.formatter = tokenFormatter()
		else: self.formatter = formatter
		self.data = data
	def setFormatter(self, formatter): self._formatter = formatter
	def getFormatter(self): return self._formatter
	def add(self, token, value): self.data[token] = str(value)
	def getTokens(self): return set(self.data.keys())
	def buildDependencyGraph(self):
		output = {}
		for token in self.tokens:
			output[token] = tokenFormatter.extractTokens(self.data[token])
		return output
	def pruneDependencyGraph(self, g):
		leaf_tokens = set()
		for token in g.keys():
			if len(g[token]) == 0:
				leaf_tokens |= set([token])
				for i in g.keys(): g[i] -= set([token])
		for leaf in leaf_tokens: del g[leaf]
		return((leaf_tokens, g))
	def getDependencies(self):
		g = self.buildDependencyGraph()
		dependencies = set()
		for token in g.keys(): dependencies |= g[token]
		return dependencies
	def isComplete(self): return len(self.getDependencies() - self.tokens) == 0
	def isCyclic(self):
		g = self.buildDependencyGraph()
		while True:
			res = self.pruneDependencyGraph(g)
			if len(res[1]) == 0: return False
			if len(res[0]) == 0: return True
			g = res[1]
	def update(self):
		if self.complete != True: raise MissingTokenError(self.getDependencies() - self.tokens)
		if self.cyclic == True: raise CyclicTokenDependencyError(self.tokens)
		while True:
			altered = False
			for key in sorted(self.tokens):
				old_value = self.data[key]
				new_value = self.formatter.format(old_value, self.data)
				if(new_value != old_value):
					altered = True
					self.data[key] = new_value
			if altered == False: break
	def format(self, s):
		self.update()
		necessary_tokens = tokenFormatter.extractTokens(s)
		missing_tokens = necessary_tokens - self.tokens
		if len(missing_tokens) > 0: raise MissingTokenError(missing_tokens)
		return self.formatter.format(s, self.data)
	def __str__(self): return 'token dictionary containing {} tokens: ({})'.format(len(self.data), ', '.join(self.tokens))
	def valueString(self):
		return ', '.join(['{}="{}"'.format(i, self.data[i]) for i in sorted(self.tokens)])
		# return ', '.join(output)
		# return 'token dictionary containing {} tokens: ({})'.format(len(self.data), ', '.join(output))
	tokens = property(getTokens, None)
	formatter = property(getFormatter, setFormatter)
	complete = property(isComplete, None)
	cyclic = property(isCyclic, None)

# A set of tokens that correctly parses multiple token values into multiple token dicts:
class tokenSet(object):
	"""This class encapsulates a set of tokens, each of which can have multiple values."""
	def __init__(self, formatter=None):
		if formatter == None: self.formatter = tokenFormatter()
		else: self.formatter = formatter
		self._tokendicts = []
		self.newTokenDict()
	def setFormatter(self, formatter): self._formatter = formatter
	def getFormatter(self): return self._formatter
	def getTokenDicts(self): return self._tokendicts
	def newTokenDict(self, data={}):
		self.tokenDicts.append(tokenDict(data=data, formatter=self.formatter))		
	def add(self, key, value):
		for tokendict in self.tokenDicts:
			tokendict.add(key, value)
	def addIterated(self, key, values):
		new_dicts = []
		for value in values:
			for old_dict in self.tokenDicts:
				new_dict = deepcopy(old_dict)
				new_dict.add(key, value)
				new_dicts.append(new_dict)
		self._tokendicts = new_dicts
	def addFromString(self, s):
		arg_parts = s.split('=', 1)
		if(len(arg_parts) != 2): raise ValueError('invalid token definition "{0}"'.format(arg))
		self.add(arg_parts[0].strip(), arg_parts[1].strip())
	def addIteratedFromFile(self, key, filename):
		token_values = set()
		with open(filename, 'rt') as f:
			for line in f.readlines():
				line = line.strip()
				if line == '': continue
				if line[0] == '#': continue
				token_values |= set([line])
		self.addIterated(key, token_values)
	def addIteratedFromString(self, s):
		match = re.match('^([^=]+)=(.*)$', s)
		token = match.group(1)
		values = match.group(2).split(',')
		if(len(values) == 1):
			try: self.addIteratedFromFile(token, values[0])
			except: raise ValueError('failed to read tokens from file "{}"'.format(values[0]))
		else: self.addIterated(token, values)
	def update(self):
		for tokendict in self.tokenDicts: tokendict.update()
	def showValues(self):
		print('{}:'.format(self.__str__()))
		for td in self.tokenDicts:
			print('  {}'.format(td.valueStrings()))
	def __iter__(self):
		self._current_key = 0
		return self
	def __next__(self):
		if self._current_key >= len(self): raise StopIteration()
		self._current_key += 1
		return self[self._current_key - 1]
	def __len__(self): return len(self.tokenDicts)
	def __str__(self): return 'token set with {} permutations'.format(len(self))
	def __getitem__(self, key): return self._tokendicts[key]
	formatter = property(getFormatter, setFormatter)
	tokenDicts = property(getTokenDicts, None)
	
########################################################################################################################
# Sections:

class MissingSectionNameError(Exception): pass
class MissingSectionTimeLimitError(Exception): pass
	
class command(object):
	def __init__(self, cmd, name, test=True, log=True):
		self.command = cmd
		self.name = name
		self.log = log
		self.test = test
	def setCommand(self, cmd): self._command = str(cmd)
	def setLog(self, log):
		if log == True: self._log = True
		else: self._log = False
	def setTest(self, test):
		if test == True: self._test = True
		else: self._test = False
	def setName(self, name): self._name = name
	def getCommand(self): return self._command
	def getLog(self): return self._log
	def getTest(self): return self._test
	def getName(self): return self._name
	def logString(self, status): return 'echo "[`date`]: command {} {}"'.format(self.name, status)
	def getStrings(self):
		output = []
		if self.log == True: output.append(self.logString('started'))
		if self.test == True: output.append('{} || {{ {}; exit 1; }}'.format(self.command, self.logString('failed')))
		else: output.append(self.command)
		if self.log == True: output.append(self.logString('finished'))
		return output
	def getQSUBString(self): return 'command("""{}""", name="{}", test={}, log={})'.format(self.command, self.name, self.test, self.log)
	command = property(getCommand, setCommand, doc='The QSUB command string')
	log = property(getLog, setLog, doc='Should the command log its status?')
	test = property(getTest, setTest, doc='Should the command test for completion?')
	name = property(getName, setName, doc='The QSUB command Name')
	strings = property(getStrings, None)
	qsubstring = property(getQSUBString, None)

class commands(UserList):
	def __init__(self):
		super().__init__()
	def append(self, new):
		if not isinstance(new, command): raise TypeError('inappropriate command type "{}"'.format(new.__class__.__name__))
		self.data.append(new)
	def add(self, cmd, name=None, test=True, log=True):
		if name == None: name = '{0}'.format(hex(len(self.data) + 1))
		self.data.append(command(cmd=cmd, name=name, test=test, log=log))
	def getStrings(self):
		output = []
		for command in self.data: output.extend(command.strings)
		return output
	def getQSUBStrings(self): return [cmd.qsubstring for cmd in self.data]
	strings = property(getStrings, None)
	qsubstrings = property(getQSUBStrings, None)

class logType(Enum):
	output = 0
	error = 1

class log(object):
	def __init__(self, logtype, base=None, file=None):
		self.logtype = logtype
		self.base = base
		self.file = file
		self.setTaskArray(False)
	def setLogtype(self, new):
		if not isinstance(new, logType): raise TypeError('inappropriate logtype type "{}"'.format(new.__class__.__name__))
		self._logtype = new
	def setBase(self, base): self._base = base
	def setFile(self, file): self._file = file
	def getLogtype(self): return self._logtype
	def getBase(self): return self._base
	def getFile(self): return self._file
	def getTaskArray(self): return self._taskarray
	def setTaskArray(self, taskarray): self._taskarray = bool(taskarray)
	def getString(self, prefix='#$'):
		if self.base != None: base_str = self.base
		else: base_str = '.'
		if self.file != None: file_str = self.file
		elif (self.logtype == logType.output):
			if self.taskarray == True: file_str = 'output-{%SNAME%}-$TASK_ID.log'
			else: file_str = 'output-{%SNAME%}.log'
		else:
			if self.taskarray == True: file_str = 'error-{%SNAME%}-$TASK_ID.log'
			else: file_str = 'error-{%SNAME%}.log'
		if self.logtype == logType.output: switch_str = 'o'
		else: switch_str = 'e'
		return '{} -{} {}/{}'.format(prefix, switch_str, base_str, file_str)
	def getQSUBString(self):
		if self.base == None: base_str = 'None'
		else: base_str = '"{}"'.format(self.base)
		if self.file == None: file_str = 'None'
		else: file_str = '"{}"'.format(self.file)
		if self.logtype == logType.output: command_str = 'output'
		else: command_str = 'error'
		return '{}(base={}, file={})'.format(command_str, base_str, file_str)
	logtype = property(getLogtype, setLogtype)
	base = property(getBase, setBase)
	file = property(getFile, setFile)
	string = property(getString, None)
	qsubstring = property(getQSUBString, None)
	taskarray = property(getTaskArray, setTaskArray)

class option(object):
	def __init__(self, switch, argument=None, value=None):
		self.switch = switch
		self.argument = argument
		self.value = value
	def setSwitch(self, switch): self._switch = switch
	def setArgument(self, argument): self._argument = argument
	def setValue(self, value): self._value = value
	def getSwitch(self): return self._switch
	def getArgument(self): return self._argument
	def getFullSwitch(self):
		if self.argument == None: return self.switch
		return '{} {}'.format(self.switch, self.argument)
	def getValue(self): return self._value
	def __str__(self):
		output = '-{}'.format(self.switch)
		if self.argument != None: output = '{} {}'.format(output, self.argument)
		if self.value != None: output = '{}={}'.format(output, self.value)
		return output
	def getString(self, prefix='#$'): return '{} {}'.format(prefix, str(self))
	def getQSUBString(self):
		opt_str = ['"{}"'.format(self.switch)]
		if self.argument != None: opt_str.append('argument="{}"'.format(self.argument))
		if self.value != None: opt_str.append('value="{}"'.format(self.value))
		return 'option({})'.format(', '.join(opt_str))
	switch = property(getSwitch, setSwitch)
	fullswitch = property(getFullSwitch, None)
	argument = property(getArgument, setArgument)
	value = property(getValue, setValue)
	string = property(getString, None)
	qsubstring = property(getQSUBString, None)

class options(UserList):
	def __init__(self):
		super().__init__()
	def add(self, switch, argument=None, value=None): self.append(option(switch, argument, value))
	def append(self, new):
		if not isinstance(new, option): raise TypeError('inappropriate option type "{}"'.format(new.__class__.__name__))
		if len(self.match(new.fullswitch)) > 0: raise ValueError('duplicate options disallowed')
		self.data.append(new)
	def __contains__(self, switch):
		for option in self.data:
			if option.fullswitch == switch: return True
		return False
	def match(self, fullswitch):
		output = options()
		for o in self.data:
			if o.fullswitch == fullswitch: output.append(o)
		return output
	def getStrings(self, prefix='#$'): return [o.getString(prefix=prefix) for o in self.data]
	def getQSUBStrings(self): return [o.qsubstring for o in self.data]
	def getSwitches(self): return [o.switch for o in self.data]
	switches = property(getSwitches, None)
	strings = property(getStrings, None)
	qsubstrings = property(getQSUBStrings, None)

class limits(options):
	def getQSUBString(self):
		limit_str = ['time="{}"'.format(self.match('l h_rt')[0].value)]
		if 'l h_vmem' in self: limit_str.append('vmem="{}"'.format(self.match('l h_vmem')[0].value))
		if 'l nodes' in self: limit_str.append('nodes={}'.format(self.match('l nodes')[0].value))
		return 'limits({})'.format(', '.join(limit_str))
	qsubstring = property(getQSUBString, None)

def jobName(name): return option(switch='N', argument=name)
def timeLimit(time): return option(switch='l', argument='h_rt', value=time)
def vmemLimit(vmem): return option(switch='l', argument='h_vmem', value=vmem)
def nodeLimit(nodes): return option(switch='l', argument='nodes', value=nodes)
def hold(hold): return option(switch='hold_jid', argument=hold)

class requirementType(Enum):
	none = 0
	path_absent = 1
	path_present = 2
	path_readable = 3
	path_writable = 4
	env_set = 5
	env_unset = 6

class requirement(object):
	def __init__(self, value, reqtype):
		self.value = value
		self.reqtype = reqtype
	def setValue(self, value): self._value = value
	def setReqtype(self, reqtype):
		if not isinstance(reqtype, requirementType): raise TypeError('inappropriate requirement type "{}"'.format(new.__class__.__name__))
		self._reqtype = reqtype
	def getValue(self): return self._value
	def getReqtype(self): return self._reqtype
	def getString(self):
		if self.reqtype == requirementType.path_present: return 'if ! test -e {0}; then echo "ERROR: file {0} not found"; exit 1; fi'.format(self.value)
		elif self.reqtype == requirementType.path_absent: return 'if test -e {0}; then echo "ERROR: file {0} exists"; exit 1; fi'.format(self.value)
		elif self.reqtype == requirementType.path_readable: return 'if ! test -r {0}; then echo "ERROR: file {0} not readable"; exit 1; fi'.format(self.value)
		elif self.reqtype == requirementType.path_writable: return 'if ! test -w {0}; then echo "ERROR: file {0} not writable"; exit 1; fi'.format(self.value)
		elif self.reqtype == requirementType.env_set: return 'if [ -z ${{{0}+x}} ]; then echo "ERROR: environment variable {0} not set"; exit 1; fi'.format(self.value)
		elif self.reqtype == requirementType.env_unset: return 'if [ -n ${{{0}+x}} ]; then echo "ERROR: environment variable {0} set"; exit 1; fi'.format(self.value)
		else: raise NotImplementedError('requirement type {} not implemented'.format(self.reqtype))
	def getQSUBString(self): return 'require("{}", "{}")'.format(self.value, self.reqtype.name)
	value = property(getValue, setValue)
	reqtype = property(getReqtype, setReqtype)
	string = property(getString, None)
	qsubstring = property(getQSUBString, None)

class requirements(UserList):
	def __init__(self):
		super().__init__()
	def add(self, value, reqtype): self.data.append(requirement(value, reqtype))
	def append(self, new):
		if not isinstance(new, requirement): raise TypeError('inappropriate requirement type "{}"'.format(new.__class__.__name__))
		self.data.append(new)
	def getStrings(self): return [r.string for r in self.data]
	def getQSUBStrings(self): return [r.qsubstring for r in self.data]
	strings = property(getStrings, None)
	qsubstrings = property(getQSUBStrings, None)

class section(object):
	def __init__(self):
		self.name = None
		self.description = None
		self.options = options()
		self.limits = limits()
		self.outfile = log(logType.output)
		self.errfile = log(logType.error)
		self.requirements = requirements()
		self.commands = commands()
	def setName(self, name): self._name = name
	def setDescription(self, description):
		if description == None: self._description = ''
		else: self._description = str(description)
	def setOptions(self, new):
		if not isinstance(new, options): raise TypeError('inappropriate options type "{}"'.format(new.__class__.__name__))
		self._options = new
	def setLimits(self, new):
		if not isinstance(new, options): raise TypeError('inappropriate options type "{}"'.format(new.__class__.__name__))
		self._limits = new
	def setOutfile(self, new):
		if not isinstance(new, log): raise TypeError('inappropriate log file type "{}"'.format(new.__class__.__name__))
		self._outfile = new
	def setErrfile(self, new):
		if not isinstance(new, log): raise TypeError('inappropriate log file type "{}"'.format(new.__class__.__name__))
		self._errfile = new
	def setRequirements(self, new):
		if not isinstance(new, requirements): raise TypeError('inappropriate requirements type "{}"'.format(new.__class__.__name__))
		self._requirements = new
	def setCommands(self, new):
		if not isinstance(new, commands): raise TypeError('inappropriate commands type "{}"'.format(new.__class__.__name__))
		self._commands = new
	def getName(self): return self._name
	def getDescription(self): return self._description
	def getOptions(self): return self._options
	def getLimits(self): return self._limits
	def getOutfile(self): return self._outfile
	def getErrfile(self): return self._errfile
	def getRequirements(self): return self._requirements
	def getCommands(self): return self._commands
	def getQSUBStrings(self):
		output = []
		if self.description == '': desc_str = 'None'
		else: desc_str = '"{}"'.format(self.description)
		output.append('section("{}", description={})'.format(self.name, desc_str))
		output.append(self.limits.qsubstring)
		output.extend(self.options.qsubstrings)
		output.append(self.outfile.qsubstring)
		output.append(self.errfile.qsubstring)
		output.extend(self.requirements.qsubstrings)
		output.extend(self.commands.qsubstrings)
		return output
	def getNotifyStrings(self):
		output = []
		if 'notify' in self.options:
			output.append('on_stop() { echo "[`date`]: imminent SIGSTOP (received SIGUSR1)"; }')
			output.append('on_kill() { echo "[`date`]: imminent SIGKILL (received SIGUSR2)"; }')
			output.append('trap \'on_stop\' SIGUSR1')
			output.append('trap \'on_kill\' SIGUSR2')
		return output
	def getStrings(self):
		output = []
		output.append(jobName(self.name).string)
		output.extend(self.limits.strings)
		output.extend(self.options.strings)
		output.append(self.outfile.string)
		output.append(self.errfile.string)
		output.extend(self.getNotifyStrings())
		output.extend(self.requirements.strings)
		output.append('echo "[`date`]: section {} started"'.format(self.name))
		output.extend(self.commands.strings)
		output.append('echo "[`date`]: section {} completed"'.format(self.name))
		output = [i.replace('{%SNAME%}', self.name) for i in output] # Replace SNAME token with real name
		return output
	def getMissingTokens(self, tokens): return self.getRequiredTokens().difference(set(tokens.keys()))
	def getRequiredTokens(self):
		output = tokenFormatter.extractTokens(self.strings)
		try: output.remove('%SNAME%')
		except: pass
		return output
	name = property(getName, setName)
	description = property(getDescription, setDescription)
	options = property(getOptions, setOptions)
	outfile = property(getOutfile, setOutfile)
	errfile = property(getErrfile, setErrfile)
	limits = property(getLimits, setLimits)
	requirements = property(getRequirements, setRequirements)
	commands = property(getCommands, setCommands)
	strings = property(getStrings, None)
	qsubstrings = property(getQSUBStrings, None)
	tokens = property(getRequiredTokens, None)

def parseTemplate(data):
	global __section__
	def qsub_section(name, description=None):
		__section__.name = name
		__section__.description = description
	def qsub_limits(time, vmem=None, nodes=None):
		__section__.limits.append(timeLimit(time))
		if vmem != None: __section__.limits.append(vmemLimit(vmem))
		if nodes != None: __section__.limits.append(nodeLimit(nodes))
	def qsub_option(switch, argument=None, value=None):
		__section__.options.add(switch, argument, value)
	def qsub_options(options):
		for opt in options:
			if isinstance(opt, str): __section__.options.add(opt, None, None)
			elif len(opt) == 2: __section__.options.add(opt[0], opt[1], None)
			else: __section__.options.add(opt[0], opt[1], opt[2])
	def qsub_hold(hold_id):
		__section__.options.append(hold(hold_id))
	def qsub_require(value, flag):
			if flag == 'path_absent': flag = requirementType.path_absent
			elif flag == 'path_present': flag = requirementType.path_present
			elif flag == 'path_readable': flag = requirementType.path_readable
			elif flag == 'path_writable': flag = requirementType.path_writable
			elif flag == 'env_set': flag = requirementType.env_set
			elif flag == 'env_unset': flag = requirementType.env_unset
			else: flag = requirementType.none
			__section__.requirements.add(value, flag)
	def qsub_outfile(base, file=None):
		__section__.outfile = log(logType.output, base=base, file=file)
	def qsub_errfile(base, file=None):
		__section__.errfile = log(logType.error, base=base, file=file)
	def qsub_default_outputs(base):
		__section__.outfile = log(logType.output, base=base, file=None)
		__section__.errfile = log(logType.error, base=base, file=None)        
	def qsub_command(cmd, name=None, test=True, log=True):
		__section__.commands.add(cmd=cmd, name=name, test=test, log=log)
	__section__ = section()
	exec(data, {'section':qsub_section, 'limits':qsub_limits, 'option':qsub_option, 'options':qsub_options, 'hold':qsub_hold, 'require':qsub_require, 'output':qsub_outfile, 'error':qsub_errfile, 'output':qsub_default_outputs, 'command':qsub_command})
	# Update the status of the log taskarray value:
	if 't' in __section__.options.switches:
		__section__.outfile.taskarray = True
		__section__.errfile.taskarray = True
	return __section__

########################################################################################################################
# Section File:

class SectionFile(object):
	def __init__(self, filename):
		self.filename = filename
		self.read()
	def getFilename(self): return self._filename
	def setFilename(self, filename):
		self._filename = str(filename)
		self.read()
	def getInputData(self): return self._input
	def isLocal(self):
		filename_parsed = urlparse(self._filename)
		if filename_parsed.netloc == '': return True
		return False
	def read(self):
		if self.local == True:
			file_handle = open(self._filename, 'rt')
			self._input = file_handle.read()
		else:
			file_handle = urlopen(self._filename)
			self._input = file_handle.read().decode('ASCII')
		file_handle.close()
	def getNecessaryTokens(self): return tokenFormatter.extractTokens(self.inputData)
	def format(self, tokens): return tokens.format(self._input)
	def parse(self, tokens):
		tokens.update() # Update the tokens before parsing the template
		section = parseTemplate(self.format(tokens))
		return section
	filename = property(getFilename, setFilename)
	local = property(isLocal, None)
	inputData = property(getInputData, None)
	tokens = property(getNecessaryTokens, None)

########################################################################################################################
# Executable code:

# Check we're at least at version 3.3.0 (required for the string formatting functions):
if (sys.hexversion < 0x03030000):
	print('ERROR: this script requires at least python 3.3')
	sys.exit(1)

# Set up the command line arguments & parse them:
parser = argparse.ArgumentParser(description = 'Expand QSUB section templates', fromfile_prefix_chars='@')
parser.add_argument('-v', '--version', action='version', version='%(prog)s {0}'.format(version))
parser.add_argument('-w', '--debug', dest='debug', action='store_true', default=False, help='show extended Python debugging information')
parser.add_argument('-e', '--executable', dest='qsub_exec', default='qsub', help='remote qsub executable')
parser.add_argument('-i', '--iterate', dest='iterated_tokens', action='append', help='comma-separaed list or file of iterated values for token')
action_group = parser.add_mutually_exclusive_group(required=False)
action_group.add_argument('-d', '--description', dest='show_description', action='store_true', default=False, help='show QSUB template description and exit')
action_group.add_argument('-t', '--tokens', dest='show_tokens', action='store_true', default=False, help='show QSUB template tokens and exit')
action_group.add_argument('-n', '--number', dest='show_number', action='store_true', default=False, help='show the number of processed jobs and exit')
action_group.add_argument('-c', '--show-code', dest='show_code', action='store_true', default=False, help='print parsed QSUB section generator code and exit')
action_group.add_argument('-s', '--submit', dest='submit', action='store_true', default=False, help='submit processed jobs to qsub')
parser.add_argument(dest='filename', metavar='<filename>', help='QSUB template file (or URL)')
args = parser.parse_known_args()
unknown_args = args[1]
args = args[0]

# Define the error function:
def error(msg):
	if args.debug == True: raise
	sys.stderr.write('ERROR: {}\n'.format(msg))
	sys.exit(1)

# Load the section file:
try: inputFile = SectionFile(args.filename)
except: error('failed to read section from file "{}"'.format(args.filename))

# If required, print the tokens required by the script and exit:
if args.show_tokens == True:
	print('\n'.join(sorted(inputFile.tokens)))
	exit(0)

# Load and process the tokens:
tokens = tokenSet()
for arg in unknown_args:
	try: tokens.addFromString(arg)
	except: error('failed to process token string "{}"'.format(arg))
if args.iterated_tokens != None:
	try:
		for arg in args.iterated_tokens: tokens.addIteratedFromString(arg)
	except: error('failed to process iterated token string "{}"'.format(arg))
try: tokens.update()
except CyclicTokenDependencyError as err: error('specified tokens have cyclic dependencies')
except MissingTokenError as err: error('specified tokens have missing dependencies: "{}"'.format(', '.join(err.tokens)))
except: error('failed to update tokens')

# Process the input file to generate a section objects:
section_data = []
try:
	for i in range(len(tokens)):
		section = inputFile.parse(tokens[i])
		if section.name == None: raise MissingSectionNameError()
		section_data.append(section)
except MissingTokenError as err: error('missing required tokens: "{}"'.format(', '.join(err.tokens)))
except MissingSectionNameError: error('section name is undefined')
except MissingSectionTimeLimitError: error('missing section time limit')
except: error('failed to generate qsub data')

# Get a padded string to hold the section names:
section_header_str = '[{{:{0}}}/{{:{0}}}]: {{}}'.format(len(str(len(tokens))))

# If required, print section description(s) and exit:
if args.show_description == True:
	if len(section_data) == 1: print(section_data[0].description)
	else:
		for i in range(len(section_data)):
			print('{} "{}"'.format(section_header_str.format(i+1, len(section_data), section_data[i].name), section_data[i].description))
	exit(0)

if args.show_number == True:
	print(len(tokens))
	exit(0)

# If requested, show the generated qsub code and exit:
if args.show_code == True:
	if len(section_data) == 1: print('\n'.join(section_data[0].qsubstrings))
	else:
		for i in range(len(section_data)):
			print(section_header_str.format(i+1, len(section_data), section_data[i].name))
			print('\n'.join(section_data[i].qsubstrings))
			if i < (len(section_data) - 1): print('\n')
	exit(0)

# If requested, Submit the scripts:
if args.submit == True:
	for i in range(len(section_data)):
		try: qsub_process = subprocess.Popen(args=[args.qsub_exec], stdin=subprocess.PIPE, stdout=subprocess.PIPE, universal_newlines=True)
		except: error('failed to spawn subprocess "{}"'.format(args.qsub_exec))
		try:
			output_data = qsub_process.communicate(input='\n'.join(section_data[i].strings))
			print(output_data[0].strip())
		except:
			qsub_process.kill()
			qsub_process.communicate()
			error('failed to submit job to subprocess "{}"'.format(args.qsub_exec))
	exit(0)

# Print out the complete code:
if len(section_data) == 1:
	print('\n'.join(section_data[0].strings))
else:
	for i in range(len(section_data)):
		print('{} ({})'.format(section_header_str.format(i+1, len(section_data), section_data[i].name), tokens[i].valueString()))
exit(0)
