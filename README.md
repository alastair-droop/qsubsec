Introduction
============

`Qsubsec` is a template language for generating `qsub` files for submission using the [SGE grid system](https://arc.liv.ac.uk/trac/SGE). By using this system, you can separate the logic of your qsub jobs from the specific data of a specific run.

Installation
============

`Qsubsec` is written in Python, and requires at least Python version 3.3. The only dependency that is likely to missing is argparse, which can be installed using pip.

Other Tools
===========
* `qslogs` is a wrapper script to view multiple qsub log files
* `qsjobs` is a wrapper around the `--xml` optupt generated by `qstat` to provide more intuitive output.

Licence
=======

These tools are released under the [GNU General Public License version 3](http://www.gnu.org/licenses/gpl.html).

Language Syntax
===============

Tokens
------
Tokens are very simple text placeholders. In templates, tokens are defined as an uppercase string surrounded by curly braces. Whitespace is not allowed in template names.

Commands
--------

**`section(name, description=None)`**  
Define the section. The name is character field that is used to identify a qsub job (using the `-N` option). If provided, the description is used to identify the template. Only a single section is possible per section file; only the last processed section command is used.

**`limits(time, vmem=None, nodes=None)`**  
Define the limits imposed by qsub on the submitted job. The time constraint is in the form ‘hh:mm:ss’, and is mandatory. The vmem constraint is a string defining the memory limit for the job, in the format speed by qsub (e.g. “1G”). The nodes constraint asks qsub for a whole node, and thus overrides the vmem constraint. The nodes parameter is an integer.

**`option(switch, argument=None, value=None)`**  
Pass further options to qsub. Options are in the form “-switch” (e.g. `-V`) “-switch argument” (e.g. `-m be`), or “-switch argument=value” (e.g. `-l cputype=amd`). Switches should be specified without the initial hyphen. In all cases, the arguments and values are treated as text.

**`options(options)`**  
Pass a list of options as simple strings. 

**`hold(hold_id)`**  
Add a hold constraint to the job. If provided, the hold_id is treated as a job ID, and the submitted job will wait until there is no job with the specified name in the queue before running.

**`require(value, flag)`**  
Add requirement checks to a qsub script. Requirements are implemented as blocks of bash code within the qsub script, so are checked once the job is running rather than at submission time. Possible flag strings are are:  
    `path_absent` 	The specified path must be absent  
    `path_present` 	The specified path must be present  
    `path_readable` 	The specified path must be readable  
    `path_writable`	The specified path must be writable  
    `env_set` 	The specified environment variable must be set  
    `env_unset` 	The specified environment variable must not be set  

**`output(base, file=None)`**  
Set the job output log file. By default, the output log is created in the current directory, and is named “output-N.log” where N is replaced by the name of the job.

**`error(base, file=None)`**  
Set the job error log file. By default, the error log is created in the current directory, and is named “error-N.log” where N is replaced by the name of the job.

**`command(cmd, name=None, test=True, log=True)`**  
Adds a command to the script. The command is specified by cmd. If name is specified, the command is named in the output logs, otherwise commands are given a number. If test is True, then script will test for successful completion of the command and generate an error if it failed. If log is True, logging text is produced in the output file.

Examples
--------

A simple "Hello, World" `qsubsec` script is:

    section("{NAME}_{STRING}", "This is a test script")
    limits(time="00:00:10", vmem="10M")
    options(["V", "cwd"])
    command("""echo "{STRING}" > ~/{NAME}_{STRING}.txt""", test=True, log=True)

The command `qsubsec test.qsubsec NAME=N STRING=Hello` will generate the following output:

    #$ -N N_Hello
    #$ -N N_Hello
    #$ -l h_rt=00:00:10
    #$ -l h_vmem=10M
    #$ -V
    #$ -cwd
    #$ -o ./output-N_Hello.log
    #$ -e ./error-N_Hello.log
    echo "[`date`]: section N_Hello started"
    echo "[`date`]: command 0x1 started"
    echo "Hello" > ~/N_Hello.txt || { echo "[`date`]: command 0x1 failed"; exit 1; }
    echo "[`date`]: command 0x1 finished"
    echo "[`date`]: section N_Hello completed"
    echo "[`date`]: section N_Hello started"
    echo "[`date`]: command 0x1 started"
    echo "Hello" > ~/N_Hello.txt || { echo "[`date`]: command 0x1 failed"; exit 1; }
    echo "[`date`]: command 0x1 finished"
    echo "[`date`]: section N_Hello completed"


